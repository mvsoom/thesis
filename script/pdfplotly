#!/usr/bin/env bash
set -e

usage() {
cat <<EOF
pdfplotly — export Plotly figure from notebook to PDF

Usage:
  pdfplotly NOTEBOOK.ipynb FIGINDEX OUT.pdf [WIDTH HEIGHT]

WIDTH/HEIGHT are in pixels (optional).
EOF
}

[ "$#" -lt 3 ] && usage && exit 1

nb="$1"
fig="$2"
out="$3"
width="${4:-}"
height="${5:-}"

tmp=$(mktemp)
trap 'rm -f "$tmp"' EXIT

# extract full figure json
jq -c --argjson k "$fig" '
[
  .cells[].outputs[]?
  | .data["application/vnd.plotly.v1+json"]?
  | select(.data | length > 0)
][ $k ]
' "$nb" > "$tmp"

python - "$tmp" "$out" "$width" "$height" <<'PY'
import sys
import plotly.io as pio
import plotly.graph_objects as go

pio.defaults.mathjax = (
    "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"
    "?config=TeX-MML-AM_SVG"
)

json_path, out, width, height = sys.argv[1:]

fig = pio.from_json(open(json_path).read(), skip_invalid=True)

# =========================
# Text preprocessing
# - inline `code` → Libertinus Mono span
# - mixed text + $math$ handling
# =========================

import re

# match inline math $...$
_math_re = re.compile(r'(?<!\\)\$(.+?)(?<!\\)\$')

# match inline code `...`
_code_re = re.compile(r'`([^`]+)`')


def _escape_text_for_tex(s):
    return (
        s.replace("\\", r"\\")
         .replace("{", r"\{")
         .replace("}", r"\}")
    )


def inject_mono_span(s):
    """Convert `code` → mono font span, but leave LaTeX untouched."""
    if "`" not in s:
        return s

    # split around math blocks so we never inject HTML inside $...$
    parts = []
    last = 0

    for m in _math_re.finditer(s):
        start, end = m.span()

        # normal text before math → apply code replacement
        if start > last:
            chunk = s[last:start]
            chunk = _code_re.sub(
                r'<span style="font-family: DejaVu Sans Mono; font-size:0.75em;">\1</span>',
                chunk,
            )
            parts.append(chunk)

        # keep math block untouched
        parts.append(s[start:end])
        last = end

    # trailing text
    if last < len(s):
        chunk = s[last:]
        chunk = _code_re.sub(
            r'<span style="font-family: DejaVu Sans Mono; font-size:0.75em;">\1</span>',
            chunk,
        )
        parts.append(chunk)

    return "".join(parts)


def latexify_string(s):
    if "$" not in s:
        return s

    # skip hovertemplate-like content
    if "%{" in s:
        return s

    matches = list(_math_re.finditer(s))
    if not matches:
        return s

    # single pure math block → leave untouched
    if len(matches) == 1 and matches[0].span() == (0, len(s)):
        return s

    parts = []
    last = 0

    for m in matches:
        start, end = m.span()

        if start > last:
            txt = s[last:start]
            if txt:
                parts.append(r"\text{" + _escape_text_for_tex(txt) + "}")

        parts.append(m.group(1))
        last = end

    if last < len(s):
        txt = s[last:]
        parts.append(r"\text{" + _escape_text_for_tex(txt) + "}")

    return "$" + "".join(parts) + "$"


def walk_and_fix(obj, parent_key=None):

    if isinstance(obj, dict):
        new = {}
        for k, v in obj.items():
            if k == "hovertemplate":
                new[k] = v
            else:
                new[k] = walk_and_fix(v, k)
        return new

    elif isinstance(obj, list):
        return [walk_and_fix(v, parent_key) for v in obj]

    elif isinstance(obj, str):
        obj = inject_mono_span(obj)
        obj = latexify_string(obj)
        return obj

    else:
        return obj


fig_dict = fig.to_plotly_json()
fig_dict = walk_and_fix(fig_dict)
fig = go.Figure(fig_dict)

# =========================
# GOD SCIENCE TEMPLATE
# =========================

axis_common = dict(
    showline=True,
    mirror="allticks",
    linecolor="#000000",
    linewidth=1.4,

    ticks="inside",
    tickwidth=1.2,

    showgrid=True,
    gridcolor="rgba(0,0,0,0.19)",
    gridwidth=1,
    griddash="dot",

    zeroline=False,

    tickfont=dict(size=15),
    title_font=dict(size=17),

    title_standoff=10,

    minor=dict(
        ticks="inside",
        ticklen=4,
        showgrid=True,
        gridcolor="rgba(0,0,0,0.07)",
        griddash="dot",
    ),
)

template = go.layout.Template(

    layout=dict(
        plot_bgcolor="white",
        paper_bgcolor="white",

        colorway=[
            "#636EFA",
            "#EF553B",
            "#00CC96",
            "#AB63FA",
            "#FFA15A",
            "#19D3F3",
            "#FF6692",
            "#B6E880",
            "#FF97FF",
            "#FECB52",
        ],

        font=dict(
            family="Libertinus Serif",
            size=15,   # slightly larger global base
            color="#111111",
        ),

        margin=dict(l=60, r=90, t=65, b=65),

        title=dict(
            x=0.03,
            xanchor="left",

            y=0.9975,
            yanchor="top",

            pad=dict(b=0, t=0),
            font=dict(size=19),
        ),

        legend=dict(
            x=1.04,
            y=1,
            xanchor="left",
            yanchor="top",

            bgcolor="rgba(0,0,0,0)",
            borderwidth=0,

            font=dict(size=13.5),

            itemsizing="trace",   # better alignment
        ),

        xaxis=axis_common,
        yaxis=axis_common,
    ),

    data=dict(

        scatter=[
            go.Scatter(
                line=dict(width=1.8),
                marker=dict(size=5),
            )
        ],

        scattergl=[
            go.Scattergl(
                line=dict(width=1.8),
                marker=dict(size=5),
            )
        ],

        histogram=[
            go.Histogram(
                opacity=0.5,
                marker=dict(line=dict(width=0)),
            )
        ],
    )
)

pio.templates["god_science"] = template

fig.update_layout(template="god_science")

for k in fig.layout:
    if k.startswith("xaxis") or k.startswith("yaxis"):
        fig.layout[k].update(axis_common)

# =========================

kwargs = {}
if width:
    kwargs["width"] = int(width)
if height:
    kwargs["height"] = int(height)

fig.write_image(out, **kwargs)
PY
